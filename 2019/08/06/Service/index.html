
<!DOCTYPE html>
<html lang class="loading">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Android四大组件之一Service - Hexo</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate">
    <meta name="keywords" content="Fechin,"> 
    <meta name="description" content="Service1、什么是Service？Service是Android中经常使用组件之中的一个，它是Android中实现程序后台执行的解决方式，它非常适合用于去执行那些不须要和用户交互且还要长期执行,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="Hexo" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <link rel="stylesheet" href="/css/diaspora.css">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
</head>
</html>
<body class="loading">
    <span id="config-title" style="display:none">Hexo</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="http://yoursite.com"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">Android四大组件之一Service</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Android四大组件之一Service</h1>
        <div class="stuff">
            <span>八月 06, 2019</span>
            
  <ul class="post-tags-list"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Shadow-付萌宸/">Shadow 付萌宸</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="1、什么是Service？"><a href="#1、什么是Service？" class="headerlink" title="1、什么是Service？"></a>1、什么是Service？</h3><p>Service是Android中经常使用组件之中的一个，它是Android中实现程序后台执行的解决方式，它非常适<br>合用于去执行那些不须要和用户交互且还要长期执行的任务。</p>
<p>这里的后台并非子线程的意思。Service默认并不会执行在子线程中。它也不会执行在一个独立的进程<br>中，它相同执行在UI线程中，因此，不要在Service中执行耗时的操作。假设须要执行耗时的操作，能够<br>在Service中创建子线程来完毕耗时操作。</p>
<p>Service的执行不依赖于不论什么用户界面，及时程序被切换到后台或者用户打开了另外一个应用程序，<br>Service仍然能够保持正常执行。这也正式Service的使用场景。</p>
<p>当某个应用程序进程被杀掉时，全部依赖于该进程的Service也会停止执行。</p>
<h3 id="2、Service-是否在-main-thread-中执行-service-里面是否能执行耗时的操作"><a href="#2、Service-是否在-main-thread-中执行-service-里面是否能执行耗时的操作" class="headerlink" title="2、Service 是否在 main thread 中执行, service 里面是否能执行耗时的操作?"></a>2、Service 是否在 main thread 中执行, service 里面是否能执行耗时的操作?</h3><p>默认情况,如果没有显示的指 service 所运行的进程, Service 和 activity 是运行在当前 app 所在<br>进程的 main thread(UI 主线程)里面。 </p>
<p>service 里面不能执行耗时的操作(网络请求,拷贝数据库,大文件 ) </p>
<p>特殊情况 ,可以在清单文件配置 service 执行所在的进程 ,让 service 在另外的进程中执行</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;service </span><br><span class="line">    android:name=<span class="string">"com.baidu.location.f"</span> </span><br><span class="line">    android:enabled=<span class="string">"true"</span> </span><br><span class="line">    android:process=<span class="string">":remote"</span> &gt; </span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3、Activity-和-Service-绑定，怎么在-Activity-中启动自己对应的-Service"><a href="#3、Activity-和-Service-绑定，怎么在-Activity-中启动自己对应的-Service" class="headerlink" title="3、Activity 和 Service 绑定，怎么在 Activity 中启动自己对应的 Service"></a>3、Activity 和 Service 绑定，怎么在 Activity 中启动自己对应的 Service</h3><p>Activity 通过 bindService(Intent service, ServiceConnection conn, int flags)跟<br>Service 进行绑定，当绑定成 功的时候 Service 会将代理对象通过回调的形式传给 conn，这样我们就<br>拿到了 Service 提供的服务代理对象。</p>
<p>在 Activity 中可以通过 startService 和 bindService 方法启动 Service。一般情况下如果想获<br>取 Service 的服务 对象那么肯定需要通过 bindService（）方法，比如音乐播放器，第三方支付等。<br>如果仅仅只是为了开启一个后台任 务那么可以使用 startService（）方法。</p>
<h3 id="4、Service-的生命周期"><a href="#4、Service-的生命周期" class="headerlink" title="4、Service 的生命周期"></a>4、Service 的生命周期</h3><p>Service 有绑定模式和非绑定模式，以及这两种模式的混合使用方式。不同的使用方法生命周期方法也不<br>同。 </p>
<p>非绑定模式：当第一次调用 startService 的时候执行的方法依次为 onCreate()、onStartCommand()<br>，（onStart()） 当 Service 关闭的时候调用 onDestory 方法。</p>
<p>绑定模式：第一次 bindService（）的时候，执行的方法为 onCreate()、onBind(）解除绑定的时候会<br>执行 onUnbind()、onDestory()。 </p>
<p>上面的两种生命周期是在相对单纯的模式下的情形。我们在开发的过程中还必须注意 Service 实例只会<br>有一个， 也就是说如果当前要启动的 Service 已经存在了那么就不会再次创建该 Service 当然也不会<br>调用 onCreate（）方法。</p>
<p>一个 Service 可以被多个客户进行绑定，只有所有的绑定对象都执行了 onBind（）方法后该<br>Service 才会销毁， 不过如果有一个客户执行了 onStart()方法，那么这个时候如果所有的 bind 客<br>户都执行了 unBind()该 Service 也不会 销毁。</p>
<h3 id="5、什么是-IntentService-以及-IntentService-的优点"><a href="#5、什么是-IntentService-以及-IntentService-的优点" class="headerlink" title="5、什么是 IntentService 以及 IntentService 的优点"></a>5、什么是 IntentService 以及 IntentService 的优点</h3><p>一、IntentService 简介 </p>
<p>IntentService 是 Service 的子类，比普通的 Service 增加了额外的功<br>能。先看 Service 本身存在两个问题： Service 不会专门启动一条单独的进程，Service 与它所在应<br>用位于同一个进程中； Service 也不是专门一条新线程，因此不应该在 Service 中直接处理耗时的任<br>务； </p>
<p>二、IntentService 特征 </p>
<p>会创建独立的 worker 线程来处理所有的 Intent 请求； 会创建独立的 worker 线程来处理<br>onHandleIntent()方法实现的代码，无需处理多线程问题； 所有请求处理完成后，IntentService 会<br>自动停止，无需调用 stopSelf()方法停止 Service； 为 Service 的 onBind()提供默认实现，返回<br>null； 为 Service 的 onStartCommand 提供默认实现，将请求 Intent 添加到队列中； </p>
<p>三、使用 IntentService </p>
<p>本人写了一个 IntentService 的使用例子供参考。该例子中一个 MainActivity 一个<br>MyIntentService，这两 个类都是四大组件当然需要在清单文件中注册。这里只给出核心代码：</p>
<p>MainActivity.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyIntentService.class); </span><br><span class="line">    intent.putExtra(<span class="string">"start"</span>, <span class="string">"MyIntentService"</span>); </span><br><span class="line">    startService(intent); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyIntentService.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> <span class="keyword">extends</span> <span class="title">IntentService</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ex = <span class="string">""</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(android.os.Message msg)</span> </span>&#123; </span><br><span class="line">            Toast.makeText(MyIntentService.<span class="keyword">this</span>, <span class="string">"-e "</span> + ex Toast.LENGTH_LONG).show(); </span><br><span class="line">            &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyIntentService</span><span class="params">()</span></span>&#123; </span><br><span class="line">            <span class="keyword">super</span>(<span class="string">"MyIntentService"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123; </span><br><span class="line">        ex = intent.getStringExtra(<span class="string">"start"</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId); </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*** 模拟执行耗时任务 * 该方法是在子线程中执行的，因此需要用到 handler 跟主线</span></span><br><span class="line"><span class="comment">        程进行通信 */</span> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">        mHandler.sendEmptyMessage(<span class="number">0</span>); </span><br><span class="line">             </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、Activity、Intent、Service-的关系"><a href="#6、Activity、Intent、Service-的关系" class="headerlink" title="6、Activity、Intent、Service 的关系"></a>6、Activity、Intent、Service 的关系</h3><p>他们都是 Android 开发中使用频率最高的类。其中 Activity 和 Service 都是 Android 四大组件之<br>一。他俩都是 Context 类的子类 ContextWrapper 的子类，因此他俩可以算是兄弟关系吧。不过兄弟<br>俩各有各自的本领，Activity 负责用户界面的显示和交互，Service 负责后台任务的处理。Activity<br>和 Service 之间可以通过 Intent 传递数据，因此 可以把 Intent 看作是通信使者。</p>
<h3 id="7、Service-和-Activity-是否在同一个线程"><a href="#7、Service-和-Activity-是否在同一个线程" class="headerlink" title="7、Service 和 Activity 是否在同一个线程"></a>7、Service 和 Activity 是否在同一个线程</h3><p>对于同一 app 来说默认情况下是在同一个线程中的，main Thread （UI Thread）。</p>
<h3 id="8、Service-里面是否可以弹吐司"><a href="#8、Service-里面是否可以弹吐司" class="headerlink" title="8、Service 里面是否可以弹吐司"></a>8、Service 里面是否可以弹吐司</h3><p>可以的。弹吐司有个条件就是得有一个 Context 上下文，而 Service 本身就是 Context 的子类，因<br>此在 Service 里面弹吐司是完全可以的。比如我们在 Service 中完成下载任务后可以弹一个吐司通知<br>用户。</p>
<h3 id="9、让一个-Service-成为前置进程"><a href="#9、让一个-Service-成为前置进程" class="headerlink" title="9、让一个 Service 成为前置进程"></a>9、让一个 Service 成为前置进程</h3><p>在启动该 Service 的时候可以在添加上如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123; </span><br><span class="line">    Notification notification = <span class="keyword">new</span> Notification(R.drawable.ic_launcher, <span class="string">"服务正 </span></span><br><span class="line"><span class="string">    在运行"</span>,System.currentTimeMillis()); </span><br><span class="line">    Intent notificationIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainActivity.class); </span><br><span class="line">    PendingIntent pendingIntent = PendingIntent.getActivity(<span class="keyword">this</span>, <span class="number">0</span>, </span><br><span class="line">    notificationIntent,<span class="number">0</span>); </span><br><span class="line">    notification.setLatestEventInfo(<span class="keyword">this</span>,<span class="string">"消息标题"</span>,<span class="string">"消息内容"</span>, pendingIntent); </span><br><span class="line">    startForeground(<span class="number">1</span>, notification); <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, </span><br><span class="line">    startId);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="10、Service-的-onStartCommand-方法的返回值"><a href="#10、Service-的-onStartCommand-方法的返回值" class="headerlink" title="10、Service 的 onStartCommand 方法的返回值"></a>10、Service 的 onStartCommand 方法的返回值</h3><p>有四种返回值，不同值代表的意思如下：</p>
<p>START_STICKY：如果 service 进程被 kill 掉，保留 service 的状态为开始状态，但不保留递送的<br>intent 对象。随 后 系 统 会 尝 试 重 新 创 建 service ， 由 于 服 务 状 态 为 开 始 状<br>态 ， 所 以 创 建 服 务 后 一 定 会 调 用 onStartCommand(Intent,int,int)方法。如果在此期<br>间没有任何启动命令被传递到 service，那么参数 Intent 将为 null。 </p>
<p>START_NOT_STICKY：“非粘性的”。使用这个返回值时，如果在执行完 onStartCommand 后，服务被异<br>常 kill 掉，系统不会自动重启该服务。 </p>
<p>START_REDELIVER_INTENT：重传 Intent。使用这个返回值时，如果在执行完 onStartCommand 后，<br>服务被异常 kill 掉，系统会自动重启该服务，并将 Intent 的值传入。 </p>
<p>START_STICKY_COMPATIBILITY：START_STICKY 的兼容版本，但不保证服务被 kill 后一定能重启。</p>
<h3 id="11、Service-的-onRebind（Intent）方法在什么情况下会执行"><a href="#11、Service-的-onRebind（Intent）方法在什么情况下会执行" class="headerlink" title="11、Service 的 onRebind（Intent）方法在什么情况下会执行"></a>11、Service 的 onRebind（Intent）方法在什么情况下会执行</h3><p>如果在 onUnbind（）方法返回 true 的情况下会执行，否则不执行。</p>
<p>官方解释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Called when <span class="keyword">new</span> clients have connected to the service, after it had previously </span><br><span class="line">been notified that all had disconnected in its onUnbind. This will only be </span><br><span class="line">called <span class="keyword">if</span> the implementation of onUnbind was overridden to <span class="keyword">return</span> <span class="keyword">true</span>.</span><br></pre></td></tr></table></figure>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        <li title='0' data-url='http://link.hhtjim.com/163/5146554.mp3'></li>
                    
                        <li title='1' data-url='http://link.hhtjim.com/qq/001faIUs4M2zna.mp3'></li>
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>
<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>
<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">
<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
